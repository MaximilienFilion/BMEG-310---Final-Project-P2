---
title: "Final Project Part 2"
author:
- "Maximilien Filion - 20598645, "
- "Aneesh Kaura - 66832304, "
- "Monica Mihailescu - 47409289 "
date: "2025-11-17"
output:
  word_document: default
  html_document: default
  pdf_document: default
---
# ============================================================================
# RNA-seq Analysis Template: Clustering and Differential Expression
# ============================================================================
# This template provides a structured framework for comprehensive gene 
# expression analysis from preprocessing through clinical validation
# ============================================================================

# Load required libraries
```{r, results='hide'}
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(cluster)
library(survival)
library(survminer)
#library(clusterProfiler)
#library(org.Hs.eg.db)
library(dplyr)
library(tibble)
library(biomaRt)   
```


set.seed(1)

# ============================================================================
# STEP 1: DATA LOADING AND INITIAL SETUP
# ============================================================================

# Load the data files
# - count_matrix: raw counts (genes x samples)
# - clinical_data: patient clinical information
# - mutation_data: mutation status for each patient
```{r}
#Load the data (from lab 7)
RNAseq_KIRC <- read.csv("RNAseq_KIRC.csv")
data_clinical_patient <- read.delim("data_clinical_patient.txt", header = TRUE, sep = "\t", skip = 4)
data_mutations <- read.delim("data_mutations.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
```

# Creates a dataframe containing all the patients common to the three datasets.
will be used in downstream applications.
```{r}
# RNAseq_KIRC dataset
rna_patient_ids <- gsub("\\.", "-", substr(colnames(RNAseq_KIRC), 1, 12))
# Data_clinical_patient dataset
clinical_patient_ids <- unique(data_clinical_patient$PATIENT_ID)
# Data_mutation dataset
mutation_patient_ids <- unique(substr(data_mutations$Tumor_Sample_Barcode, 1, 12))
# Common patients
common_patients <- Reduce(intersect, list(rna_patient_ids,
clinical_patient_ids, mutation_patient_ids))

# Patients in all three datasets
common_patients <- Reduce(intersect, list(
  rna_patient_ids,
  clinical_patient_ids,
  mutation_patient_ids
))
cat("Number of patients in ALL datasets:", length(common_patients), "\n")
```

# Trim the datasets to only include the common patients
```{r}
#For the RNA seq dataset, we want to keep all the common patient columns and the ensembl gene ID (i.e.Column "X")
# Trim the RNA sequencing dataset
common_patients_and_X <- c(common_patients, "X")
RNAseq_KIRC <- RNAseq_KIRC[ , gsub("\\.", "-", substr(colnames(RNAseq_KIRC), 1, 12)) %in% common_patients_and_X]

# Trim the clinical dataset
data_clinical_patient <- data_clinical_patient[data_clinical_patient$PATIENT_ID %in% common_patients, ]

# Trim the mutation dataset
data_mutations <- data_mutations[substr(data_mutations$Tumor_Sample_Barcode, 1, 12) %in% common_patients, ]
```

<!-- # Merge the different ensembl version in the RNAseq dataframe -->
<!-- ```{r} -->
<!-- # Strip the ensembl version -->
<!-- RNAseq_KIRC$X <- gsub("\\..*$", "", RNAseq_KIRC$X) -->

<!-- # Collapse the duplicates -- GenAI was used for this part -->
<!-- RNAseq_KIRC_novers <- RNAseq_KIRC %>% -->
<!--   group_by(X) %>% -->
<!--   summarise(across(everything(), sum)) -->
<!-- ``` -->
The code above only cuts ~50 duplicate genes and takes a while to run. It was commented to signify that we thought about it but did not use it due to computational ressources. 


# Check for missing values
```{r}
# RNA-seq:
rnaseq_missing <- sum(is.na(RNAseq_KIRC))
cat("Missing values in RNA-seq count matrix:", rnaseq_missing, "\n")

# Clinical: Check key columns
key_clinical_cols <- c("PATIENT_ID", "AGE", "SEX", "OS_STATUS", "OS_MONTHS", "DSS_STATUS", "DSS_MONTHS", "DFS_STATUS", "DFS_MONTHS", "PFS_STATUS", "PFS_MONTHS", "PATH_T_STAGE", "PATH_N_STAGE", "PATH_M_STAGE", "AJCC_PATHOLOGIC_TUMOR_STAGE")
existing_cols <- key_clinical_cols[key_clinical_cols %in% colnames(data_clinical_patient)]

if(length(existing_cols) > 0) {
  for(col in existing_cols) {
    missing_count <- sum(is.na(data_clinical_patient[[col]]) | data_clinical_patient[[col]] == "")
    cat("Missing/empty values in", col, ":", missing_count, "\n")
  }
}

# Mutations: Check key columns
cat("\nMissing values in Tumor_Sample_Barcode:", sum(is.na(data_mutations$Tumor_Sample_Barcode)), "\n")
cat("Missing/empty values in Hugo_Symbol:", sum(is.na(data_mutations$Hugo_Symbol) | data_mutations$Hugo_Symbol == ""), "\n")
cat("Missing/empty values in Variant_Classificatoin:", sum(is.na(data_mutations$Variant_Classification) | data_mutations$Variant_Classificationl == ""), "\n")
cat("Missing/empty values in Consequence:", sum(is.na(data_mutations$Consequence) | data_mutations$Consequence == ""), "\n")
cat("Missing/epmty values in Impact:", sum(is.na(data_mutations$IMPACT) | data_mutations$IMPACT == ""), "\n\n")
```


# ============================================================================
# STEP 2: PREPROCESSING
# ============================================================================

## 2.1: Normalization using DESeq2
# GOAL: Account for sequencing depth and composition bias

# TODO: Create DESeq2 object from raw counts
# TODO: Estimate size factors
# TODO: Extract normalized counts
```{r}
# Create DESeq2 object from raw counts
# Prepare count matrix (genes as rows, samples as columns)
count_matrix <- as.matrix(RNAseq_KIRC[, -1])  # Remove gene name column
rownames(count_matrix) <- RNAseq_KIRC[, 1]    # Set gene names as row names

# Create a simple sample metadata data frame
# For normalization, we just need a basic colData with sample names
coldata <- data.frame(
  sample = colnames(count_matrix),
  condition = rep("tumor", ncol(count_matrix))  # Placeholder condition
)
rownames(coldata) <- coldata$sample

cat("Count matrix dimensions:", dim(count_matrix), "\n")

# Create DESeq2 dataset object
dds <- DESeqDataSetFromMatrix(
  countData = count_matrix,
  colData = coldata,
  design = ~ 1  # No DE, normalization only
)
cat("DESeq2 object created successfully\n\n")

# Estimate size factors
dds <- estimateSizeFactors(dds)

# Get size factors
size_factors <- sizeFactors(dds)
cat("Size factor summary:\n")
print(summary(size_factors))
cat("\n")

# Extract normalized counts
normalized_counts <- counts(dds, normalized = TRUE)
cat("Normalized count matrix dimensions:", dim(normalized_counts), "\n")
```

## 2.2: Log-transformation
# GOAL: Stabilize variance and make data more normally distributed

# TODO: Apply log2 transformation and VST
```{r}
# simple Log2(x+1) transformation 
log_norm_counts <- log2(normalized_counts + 1)

cat("Log transform count matrix dimensions:", dim(log_norm_counts), "\n")
cat("Log transformation range:", range(log_norm_counts), "\n\n")

# Apply VST (recommended for >30 samples) - Applies variance-stabilizing transformation, 'blind' Ignores experimental design
vsd <- vst(dds, blind = TRUE)
vst_counts <- assay(vsd)

cat("VST count matrix dimensions:", dim(vst_counts), "\n")
cat("VST value range:", range(vst_counts), "\n\n")
```

## 2.3: Z-score transformation
# GOAL: Standardize gene expression across samples

# TODO: Calculate z-scores per gene (across samples)
# TODO: Verify mean ≈ 0 and sd ≈ 1 for each gene
```{r}
# Z-score the log-transformed counts (by gene)
z_log <- t(scale(t(log_norm_counts)))

cat("Z-scored log2 matrix dimensions:", dim(z_log), "\n")
cat("Z-scored log2 range:", range(z_log, na.rm = TRUE), "\n\n")

# Z-score the VST-transformed counts (by gene)
z_vst <- t(scale(t(vst_counts)))

cat("Z-scored VST matrix dimensions:", dim(z_vst), "\n")
cat("Z-scored VST range:", range(z_vst, na.rm = TRUE), "\n\n")
```


# ============================================================================
# INVESTIGATION 1: Global Expression-Based Clustering
# RQ 2.1: Do patients cluster into distinct phenotype subtypes?
# ============================================================================

# Filter the most variable genes 
2000 most variable genes were selected. 2000 is an arbitrary number that was chosen to reduce the size of the dataset. Running distance on 60660 observations was too computationally intensive.
```{r}
# compute variance
gene_vars <- apply(z_vst, 1, var)

#Rank the genes by variance
top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:2000]

# Create a subset matrix with the top 2000 genes
expr_z_top <- z_vst[top_genes, ]
```


# Plot PCA and look for distinct group
```{r}
pca_res <- prcomp(t(expr_z_top), scale = FALSE)  # already Z-scored, so scale=FALSE

# Percentage variance explained
pve <- (pca_res$sdev^2) / sum(pca_res$sdev^2)

# Scree plot
ggplot(data.frame(PC = 1:10, Var = pve[1:10]),
       aes(x = PC, y = Var)) +
  geom_bar(stat = "identity") +
  ggtitle("Scree Plot: Variance Explained by PCA Components") +
  ylab("Proportion of Variance Explained")

# PCA scatter plot: PC1 vs PC2
pca_df <- data.frame(
  Sample = rownames(t(expr_z_top)),
  PC1 = pca_res$x[,1],
  PC2 = pca_res$x[,2]
)

ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_point(alpha = 0.7) +
  ggtitle("PCA of KIRC Patients (Top 2000 Variance Genes)") +
  xlab(paste0("PC1 (", round(pve[1] * 100, 1), "%)")) +
  ylab(paste0("PC2 (", round(pve[2] * 100, 1), "%)")) +
  theme_minimal()
```

# Compute distance and Apply clustering on expression data
```{r}
dist_mat <- dist(t(expr_z_top), method = "euclidean")
hc <- hclust(dist_mat, method = "ward.D2")

plot(hc, labels = FALSE, hang = -1)
```


# Plot the distance heatmap
```{r}
pheatmap(
  t(expr_z_top),
  show_rownames = FALSE,
  show_colnames = FALSE,
  clustering_method = "ward.D2"
)
```
#Cutting Dendogram
```{r}
# Define Patient Clusters from Dendrogram
# Cut the dendogram to assign patients to distinct clusters

# Silhouette Method (Quality of clustering)
# Higher silhouette = better separation between clusters
p2 <- fviz_nbclust(t(expr_z_top), FUN = hcut, method = "silhouette", k.max = 10) +
  ggtitle("Silhouette Method: Optimal Number of Clusters") +
  geom_vline(xintercept = 6, linetype = "dashed", color = "red")
print(p2)
```
```{r}
# Cut the Dendrogram into k=6 Clusters

# Cut dendrogram at k=6
k <- 6
patient_clusters <- cutree(hc, k = k)

# Create a dataframe with cluster assignments
cluster_df <- data.frame(
  PATIENT_ID = names(patient_clusters),
  Cluster = patient_clusters,
  Cluster_Label = paste0("C", patient_clusters),
  stringsAsFactors = FALSE
)

# Summary of cluster sizes
cat("Cluster sizes:\n")
print(table(cluster_df$Cluster_Label))
cat("\n")

```
###### Iinvestigation 3
```{r}
#Clean Ensembl IDs and map to gene symbols

# Remove version numbers from Ensembl IDs
clean_ids <- sub("\\..*", "", rownames(vst_counts))
rownames(vst_counts) <- clean_ids
rownames(z_vst) <- clean_ids

# Get gene symbols from Ensembl
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = clean_ids,
  mart = mart
)

# Convert to gene symbols
expr_df <- as.data.frame(vst_counts) %>%
  mutate(ensembl_gene_id = rownames(vst_counts)) %>%
  left_join(mapping, by = "ensembl_gene_id") %>%
  filter(hgnc_symbol != "") %>%
  distinct(hgnc_symbol, .keep_all = TRUE)

rownames(expr_df) <- expr_df$hgnc_symbol
expr_symbol <- as.matrix(expr_df[, -c(ncol(expr_df)-1, ncol(expr_df))])

# Same for z-scores
z_df <- as.data.frame(z_vst) %>%
  mutate(ensembl_gene_id = rownames(z_vst)) %>%
  left_join(mapping, by = "ensembl_gene_id") %>%
  filter(hgnc_symbol != "") %>%
  distinct(hgnc_symbol, .keep_all = TRUE)

rownames(z_df) <- z_df$hgnc_symbol
z_scores_symbol <- as.matrix(z_df[, -c(ncol(z_df)-1, ncol(z_df))])

cat("Genes with symbols:", nrow(expr_symbol), "\n\n")
```
```{r}
# Subset to Samples(Patients) with Stage Info

# Extract patient IDs and match to clinical data
rnaseq_patient_ids <- substr(gsub("\\.", "-", colnames(expr_symbol)), 1, 12)

age_info <- data.frame(
  sample_id = colnames(expr_symbol),
  patient_id = rnaseq_patient_ids
) %>%
  left_join(
    data_clinical_patient %>% 
      dplyr::select(PATIENT_ID, AGE) %>%
      rename(patient_id = PATIENT_ID, age = AGE),
    by = "patient_id"
  ) %>%
  filter(!is.na(age) & age != "")

age_info$age <- cut(
  age_info$age,
  breaks = c(0, 49, 59, 69, 79, 100),
  labels = c("<49", "50-59", "60-69", "70-79", ">80")
)

# Subset expression matrices
expr_staged <- expr_symbol[, age_info$sample_id]
z_scores_staged <- z_scores_symbol[, age_info$sample_id]

cat("Samples with age:", nrow(age_info), "\n")
print(table(age_info$age))
cat("\n")
```
```{r}
#Select top 500 Most Variable genes

# Calculate variance for each gene
gene_variance <- apply(expr_staged, 1, var)

# Select top 500
top500_genes <- names(sort(gene_variance, decreasing = TRUE)[1:500])

cat("Top 500 genes selected\n")
cat("Variance range:", round(range(gene_variance[top500_genes]), 2), "\n\n")

#This shows how expressed each gene is, and take the top 500 genes that have the largest variance in expression. 
#Each patient expresses a certain amount of each gene,
#so the highest variance is intersting as something might be happening, Could be indicative. 
```
```{r}
#ANOVA Test by age

# Test if genes differ across stages
anova_results_age <- data.frame(
  gene = top500_genes,
  p_value = sapply(top500_genes, function(g) {
    fit <- aov(expr_staged[g, ] ~ factor(age_info$age))
    summary(fit)[[1]]["Pr(>F)"][1, 1]
  })
)
```

```{r}
#Multiple testing correction
anova_results_age$p_adj <- p.adjust(anova_results_age$p_value, method = "BH")
anova_results_age$significant <- anova_results_age$p_adj < 0.05

cat("Significant genes (FDR < 0.05):", sum(anova_results_age$significant), "\n")
print(anova_results_age %>% arrange(p_adj) %>% head(10))
cat("\n")
```
```{r}
# After ANOVA results, specifically test GZMB
if("GZMB" %in% rownames(expr_staged)) {
  gzmb_test <- data.frame(
    age = age_info$age,
    expression = expr_staged["GZMB", ]
  )
  
  # Statistical test
  gzmb_anova <- aov(expression ~ age, data = gzmb_test)
  print("GZMB by Age Group:")
  print(summary(gzmb_anova))
  
  # Post-hoc test to compare >80 vs others
  gzmb_posthoc <- TukeyHSD(gzmb_anova)
  print(gzmb_posthoc)
  
  # Mean expression by age group
  print(gzmb_test %>% group_by(age) %>% 
        summarise(mean_expr = mean(expression), 
                  sd_expr = sd(expression)))
}
```
```{r}
# Boxplot for GZMB across age groups
if("GZMB" %in% rownames(expr_staged)) {
  ggplot(gzmb_test, aes(x = age, y = expression, fill = age)) +
    geom_boxplot() +
    geom_jitter(width = 0.2, alpha = 0.3) +
    labs(title = "GZMB Expression by Age Group",
         x = "Age Group", y = "VST Expression") +
    theme_minimal()
}
```


###### Iinvestigation 4

########Investigation 5

```{r}
# Subset to Samples(Patients) with Stage Info

# Extract patient IDs and match to clinical data
rnaseq_patient_ids <- substr(gsub("\\.", "-", colnames(expr_symbol)), 1, 12)

stage_info <- data.frame(
  sample_id = colnames(expr_symbol),
  patient_id = rnaseq_patient_ids
) %>%
  left_join(
    data_clinical_patient %>% 
      dplyr::select(PATIENT_ID, AJCC_PATHOLOGIC_TUMOR_STAGE) %>%
      rename(patient_id = PATIENT_ID, stage = AJCC_PATHOLOGIC_TUMOR_STAGE),
    by = "patient_id"
  ) %>%
  filter(!is.na(stage) & stage != "")

# Subset expression matrices
expr_staged <- expr_symbol[, stage_info$sample_id]
z_scores_staged <- z_scores_symbol[, stage_info$sample_id]

cat("Samples with stage:", nrow(stage_info), "\n")
print(table(stage_info$stage))
cat("\n")
```

```{r}
#Select top 500 Most Variable genes

# Calculate variance for each gene
gene_variance <- apply(expr_staged, 1, var)

# Select top 500
top500_genes <- names(sort(gene_variance, decreasing = TRUE)[1:500])

cat("Top 500 genes selected\n")
cat("Variance range:", round(range(gene_variance[top500_genes]), 2), "\n\n")

#This shows how expressed each gene is, and take the top 500 genes that have the largest variance in expression. 
#Each patient expresses a certain amount of each gene,
#so the highest variance is intersting as something might be happening, Could be indicative. 
```

```{r}
#ANOVA Test by stage

# Test if genes differ across stages
anova_results <- data.frame(
  gene = top500_genes,
  p_value = sapply(top500_genes, function(g) {
    fit <- aov(expr_staged[g, ] ~ factor(stage_info$stage))
    summary(fit)[[1]]["Pr(>F)"][1, 1]
  })
)
```

```{r}
#Multiple testing correction

anova_results$p_adj <- p.adjust(anova_results$p_value, method = "BH")
anova_results$significant <- anova_results$p_adj < 0.05

cat("Significant genes (FDR < 0.05):", sum(anova_results$significant), "\n")
print(anova_results %>% arrange(p_adj) %>% head(10))
cat("\n")
```

```{r}
#Heatmap Vizualization
#Out of the 500 most variable, only 85 are significant -> therefore, should only see small clustering....

top500_matrix <- z_scores_staged[top500_genes, stage_info$sample_id]

annotation <- data.frame(
  Stage = factor(stage_info$stage),
  row.names = stage_info$sample_id
)

pheatmap(
  top500_matrix,
  annotation_col = annotation,
  show_rownames = FALSE,
  show_colnames = FALSE,
  main = "Top 500 Variable Genes by Stage"
)
```

```{r}
#Identify the oncogenes

oncogenes <- c("MYC","KRAS","NRAS","HRAS","EGFR","ERBB2","PIK3CA",
               "BRAF","AKT1","AKT2","MDM2","CCND1","CDK4","CDK6",
               "MET","RET","ALK","ROS1","FGFR1","FGFR2")

oncogenes_in_data <- intersect(rownames(expr_staged), oncogenes)

cat("Oncogenes found:", length(oncogenes_in_data), "\n")
cat(paste(oncogenes_in_data, collapse = ", "), "\n\n")
```

```{r}
#Oncogene stage correlation
#Spearman correlation is a monotonic relationship between 2 variables
#In this case, we are looking at does expression go up or down with stage

if (length(oncogenes_in_data) > 0) {
  
  # Convert stage to numeric (I=1, II=2, III=3, IV=4)
  stage_numeric <- as.numeric(factor(
    stage_info$stage, 
    levels = c("STAGE I", "STAGE II", "STAGE III", "STAGE IV")
  ))
  
  # Test correlation for each oncogene
  oncogene_results <- data.frame(
    gene = oncogenes_in_data,
    correlation = sapply(oncogenes_in_data, function(g) {
      cor.test(stage_numeric, expr_staged[g, ], method = "spearman")$estimate
    }),
    p_value = sapply(oncogenes_in_data, function(g) {
      cor.test(stage_numeric, expr_staged[g, ], method = "spearman")$p.value
    })
  )
  
  oncogene_results$p_adj <- p.adjust(oncogene_results$p_value, method = "BH")
  oncogene_results$significant <- oncogene_results$p_adj < 0.05
  oncogene_results$direction <- ifelse(oncogene_results$correlation > 0, "UP", "DOWN")
  
  cat("Oncogene correlation results:\n")
  print(oncogene_results %>% arrange(p_adj))
  cat("\n")
}
```
```{r}
#Plot significant outcomes

if (exists("oncogene_results")) {
  sig_oncogenes <- oncogene_results %>% 
    filter(significant) %>% 
    pull(gene)
  
  if (length(sig_oncogenes) > 0) {
    for (gene in sig_oncogenes) {
      corr <- oncogene_results$correlation[oncogene_results$gene == gene]
      p_adj <- oncogene_results$p_adj[oncogene_results$gene == gene]
      
      plot_data <- data.frame(
        expression = expr_staged[gene, ],
        stage = factor(stage_info$stage)
      )
      
      p <- ggplot(plot_data, aes(stage, expression, fill = stage)) +
        geom_boxplot() +
        labs(
          title = paste(gene, "| ρ =", round(corr, 3), 
                       "| p_adj =", format(p_adj, scientific = TRUE, digits = 2)),
          x = "Tumor Stage", 
          y = "Log2 Expression"
        ) +
        theme_bw() +
        theme(legend.position = "none")
      
      print(p)
    }
  } else {
    cat("No significant oncogenes to plot\n")
  }
}
```

