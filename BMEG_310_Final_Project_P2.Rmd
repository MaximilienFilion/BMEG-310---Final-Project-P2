---
title: "Final Project Part 2"
author:
- "Maximilien Filion - 20598645, "
- "Aneesh Kaura - 66832304, "
- "Monica Mihailescu - 47409289 "
date: "2025-11-17"
output:
  word_document: default
  html_document: default
  pdf_document: default
---
# ============================================================================
# RNA-seq Analysis Template: Clustering and Differential Expression
# ============================================================================
# This template provides a structured framework for comprehensive gene 
# expression analysis from preprocessing through clinical validation
# ============================================================================

# Load required libraries
```{r, results='hide'}
library(DESeq2)
library(pheatmap)
library(ggplot2)
library(cluster)
library(survival)
library(survminer)
#library(clusterProfiler)
#library(org.Hs.eg.db)
library(dplyr)
library(tibble)
```


set.seed(123)

# ============================================================================
# STEP 1: DATA LOADING AND INITIAL SETUP
# ============================================================================

# Load the data files
# - count_matrix: raw counts (genes x samples)
# - clinical_data: patient clinical information
# - mutation_data: mutation status for each patient
```{r}
#Load the data (from lab 7)
RNAseq_KIRC <- read.csv("RNAseq_KIRC.csv")
data_clinical_patient <- read.delim("data_clinical_patient.txt", header = TRUE, sep = "\t", skip = 4)
data_mutations <- read.delim("data_mutations.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
```

# Creates a dataframe containing all the patients common to the three datasets.
will be used in downstream applications.
```{r}
# RNAseq_KIRC dataset
rna_patient_ids <- gsub("\\.", "-", substr(colnames(RNAseq_KIRC), 1, 12))
# Data_clinical_patient dataset
clinical_patient_ids <- unique(data_clinical_patient$PATIENT_ID)
# Data_mutation dataset
mutation_patient_ids <- unique(substr(data_mutations$Tumor_Sample_Barcode, 1, 12))
# Common patients
common_patients <- Reduce(intersect, list(rna_patient_ids,
clinical_patient_ids, mutation_patient_ids))

# Patients in all three datasets
common_patients <- Reduce(intersect, list(
  rna_patient_ids,
  clinical_patient_ids,
  mutation_patient_ids
))
cat("Number of patients in ALL datasets:", length(common_patients), "\n")
```

# Trim the datasets to only include the common patients
```{r}
#For the RNA seq dataset, we want to keep all the common patient columns and the ensembl gene ID (i.e.Column "X")
# Trim the RNA sequencing dataset
common_patients_and_X <- c(common_patients, "X")
RNAseq_KIRC <- RNAseq_KIRC[ , gsub("\\.", "-", substr(colnames(RNAseq_KIRC), 1, 12)) %in% common_patients_and_X]

# Trim the clinical dataset
data_clinical_patient <- data_clinical_patient[data_clinical_patient$PATIENT_ID %in% common_patients, ]

# Trim the mutation dataset
data_mutations <- data_mutations[substr(data_mutations$Tumor_Sample_Barcode, 1, 12) %in% common_patients, ]
```

<!-- # Merge the different ensembl version in the RNAseq dataframe -->
<!-- ```{r} -->
<!-- # Strip the ensembl version -->
<!-- RNAseq_KIRC$X <- gsub("\\..*$", "", RNAseq_KIRC$X) -->

<!-- # Collapse the duplicates -- GenAI was used for this part -->
<!-- RNAseq_KIRC_novers <- RNAseq_KIRC %>% -->
<!--   group_by(X) %>% -->
<!--   summarise(across(everything(), sum)) -->
<!-- ``` -->
The code above only cuts ~50 duplicate genes and takes a while to run. It was commented to signify that we thought about it but did not use it due to computational ressources. 


# Check for missing values
```{r}
# RNA-seq:
rnaseq_missing <- sum(is.na(RNAseq_KIRC))
cat("Missing values in RNA-seq count matrix:", rnaseq_missing, "\n")

# Clinical: Check key columns
key_clinical_cols <- c("PATIENT_ID", "AGE", "SEX", "OS_STATUS", "OS_MONTHS", "DSS_STATUS", "DSS_MONTHS", "DFS_STATUS", "DFS_MONTHS", "PFS_STATUS", "PFS_MONTHS", "PATH_T_STAGE", "PATH_N_STAGE", "PATH_M_STAGE", "AJCC_PATHOLOGIC_TUMOR_STAGE")
existing_cols <- key_clinical_cols[key_clinical_cols %in% colnames(data_clinical_patient)]

if(length(existing_cols) > 0) {
  for(col in existing_cols) {
    missing_count <- sum(is.na(data_clinical_patient[[col]]) | data_clinical_patient[[col]] == "")
    cat("Missing/empty values in", col, ":", missing_count, "\n")
  }
}

# Mutations: Check key columns
cat("\nMissing values in Tumor_Sample_Barcode:", sum(is.na(data_mutations$Tumor_Sample_Barcode)), "\n")
cat("Missing/empty values in Hugo_Symbol:", sum(is.na(data_mutations$Hugo_Symbol) | data_mutations$Hugo_Symbol == ""), "\n")
cat("Missing/empty values in Variant_Classificatoin:", sum(is.na(data_mutations$Variant_Classification) | data_mutations$Variant_Classificationl == ""), "\n")
cat("Missing/empty values in Consequence:", sum(is.na(data_mutations$Consequence) | data_mutations$Consequence == ""), "\n")
cat("Missing/epmty values in Impact:", sum(is.na(data_mutations$IMPACT) | data_mutations$IMPACT == ""), "\n\n")
```


# ============================================================================
# STEP 2: PREPROCESSING
# ============================================================================

## 2.1: Normalization using DESeq2
# GOAL: Account for sequencing depth and composition bias

# TODO: Create DESeq2 object from raw counts
# TODO: Estimate size factors
# TODO: Extract normalized counts
```{r}
# Create DESeq2 object from raw counts
# Prepare count matrix (genes as rows, samples as columns)
count_matrix <- as.matrix(RNAseq_KIRC[, -1])  # Remove gene name column
rownames(count_matrix) <- RNAseq_KIRC[, 1]    # Set gene names as row names

# Create a simple sample metadata data frame
# For normalization, we just need a basic colData with sample names
coldata <- data.frame(
  sample = colnames(count_matrix),
  condition = rep("tumor", ncol(count_matrix))  # Placeholder condition
)
rownames(coldata) <- coldata$sample

cat("Count matrix dimensions:", dim(count_matrix), "\n")

# Create DESeq2 dataset object
dds <- DESeqDataSetFromMatrix(
  countData = count_matrix,
  colData = coldata,
  design = ~ 1  # No DE, normalization only
)
cat("DESeq2 object created successfully\n\n")

# Estimate size factors
dds <- estimateSizeFactors(dds)

# Get size factors
size_factors <- sizeFactors(dds)
cat("Size factor summary:\n")
print(summary(size_factors))
cat("\n")

# Extract normalized counts
normalized_counts <- counts(dds, normalized = TRUE)
cat("Normalized count matrix dimensions:", dim(normalized_counts), "\n")
```

## 2.2: Log-transformation
# GOAL: Stabilize variance and make data more normally distributed

# TODO: Apply log2 transformation and VST
```{r}
# simple Log2(x+1) transformation 
log_norm_counts <- log2(normalized_counts + 1)

cat("Log transform count matrix dimensions:", dim(log_norm_counts), "\n")
cat("Log transformation range:", range(log_norm_counts), "\n\n")

# Apply VST (recommended for >30 samples) - Applies variance-stabilizinvg transformation, 'blind' Ignores experimental design
vsd <- vst(dds, blind = TRUE)
vst_counts <- assay(vsd)

cat("VST count matrix dimensions:", dim(vst_counts), "\n")
cat("VST value range:", range(vst_counts), "\n\n")
```

## 2.3: Z-score transformation
# GOAL: Standardize gene expression across samples

# TODO: Calculate z-scores per gene (across samples)
# TODO: Verify mean ≈ 0 and sd ≈ 1 for each gene
```{r}
# Z-score the log-transformed counts (by gene)
z_log <- t(scale(t(log_norm_counts)))

cat("Z-scored log2 matrix dimensions:", dim(z_log), "\n")
cat("Z-scored log2 range:", range(z_log, na.rm = TRUE), "\n\n")

# Z-score the VST-transformed counts (by gene)
z_vst <- t(scale(t(vst_counts)))

cat("Z-scored VST matrix dimensions:", dim(z_vst), "\n")
cat("Z-scored VST range:", range(z_vst, na.rm = TRUE), "\n\n")
```


# ============================================================================
# INVESTIGATION 1: Global Expression-Based Clustering
# RQ 2.1: Do patients cluster into distinct phenotype subtypes?
# ============================================================================

# Filter the most variable genes 
2000 most variable genes were selected. 2000 is an arbitrary number that was chosen to reduce the size of the dataset. Running distance on 60660 observations was too computationally intensive.
```{r}
# compute variance
gene_vars <- apply(z_vst, 1, var)

#Rank the genes by variance
top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:2000]

# Create a subset matrix with the top 2000 genes
expr_z_top <- z_vst[top_genes, ]
```


# Plot PCA and look for distinct group
```{r}
pca_res <- prcomp(t(expr_z_top), scale = FALSE)  # already Z-scored, so scale=FALSE

# Percentage variance explained
pve <- (pca_res$sdev^2) / sum(pca_res$sdev^2)

# Scree plot
ggplot(data.frame(PC = 1:10, Var = pve[1:10]),
       aes(x = PC, y = Var)) +
  geom_bar(stat = "identity") +
  ggtitle("Scree Plot: Variance Explained by PCA Components") +
  ylab("Proportion of Variance Explained")

# PCA scatter plot: PC1 vs PC2
pca_df <- data.frame(
  Sample = rownames(t(expr_z_top)),
  PC1 = pca_res$x[,1],
  PC2 = pca_res$x[,2]
)

ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_point(alpha = 0.7) +
  ggtitle("PCA of KIRC Patients (Top 2000 Variance Genes)") +
  xlab(paste0("PC1 (", round(pve[1] * 100, 1), "%)")) +
  ylab(paste0("PC2 (", round(pve[2] * 100, 1), "%)")) +
  theme_minimal()
```

# Compute distance and Apply clustering on expression data
```{r}
dist_mat <- dist(t(expr_z_top), method = "euclidean")
hc <- hclust(dist_mat, method = "ward.D2")

plot(hc, labels = FALSE, hang = -1)
```


# Plot the distance heatmap
```{r}
pheatmap(
  t(expr_z_top),
  show_rownames = FALSE,
  show_colnames = FALSE,
  clustering_method = "ward.D2"
)
```
#Cutting Dendogram
```{r}
# Define Patient Clusters from Dendrogram
# Cut the dendogram to assign patients to distinct clusters

# Silhouette Method (Quality of clustering)
# Higher silhouette = better separation between clusters
p2 <- fviz_nbclust(t(expr_z_top), FUN = hcut, method = "silhouette", k.max = 10) +
  ggtitle("Silhouette Method: Optimal Number of Clusters") +
  geom_vline(xintercept = 6, linetype = "dashed", color = "red")
print(p2)
```
```{r}
# Cut the Dendrogram into k=6 Clusters

# Cut dendrogram at k=6
k <- 6
patient_clusters <- cutree(hc, k = k)

# Create a dataframe with cluster assignments
cluster_df <- data.frame(
  PATIENT_ID = names(patient_clusters),
  Cluster = patient_clusters,
  Cluster_Label = paste0("C", patient_clusters),
  stringsAsFactors = FALSE
)

# Summary of cluster sizes
cat("Cluster sizes:\n")
print(table(cluster_df$Cluster_Label))
cat("\n")

```

# ============================================================================
# INVESTIGATION 2: High-Variance Gene Clustering
# RQ 2.2: How does focusing on variable genes influence clustering?
# ============================================================================

## GOAL: Determine if highly variable genes drive clustering patterns

## Step 2.1: Identify top variable genes
# TODO: Calculate variance for each gene (use log-transformed data)
# TODO: Rank genes by variance
# TODO: Select top 500 most variable genes
# TODO: Create filtered expression matrix (500 genes x all samples)

## Step 2.2: Visualize variable genes
# TODO: Plot variance distribution across all genes
# TODO: Highlight top 500 selected genes
# TODO: Optional: heatmap of top variable genes

## Step 2.3: Re-cluster with variable genes only
# TODO: Calculate new distance matrix on 500-gene subset
# TODO: Perform hierarchical clustering
# TODO: Determine optimal k (may differ from Investigation 1)
# TODO: Cut tree and assign new cluster labels

## Step 2.4: Compare clustering results
# TODO: Create confusion matrix: Investigation 1 clusters vs Investigation 2 clusters
# TODO: Calculate adjusted Rand index (ARI) to measure agreement
# TODO: Identify samples that switch clusters
# TODO: PCA visualization with both cluster assignments

## Step 2.5: Biological interpretation
# TODO: Are variable gene clusters more/less distinct?
# TODO: Does focusing on variable genes change cluster structure?
# TODO: Which clustering is more biologically coherent?

## CONCLUSION FOR RQ 2.2:
# TODO: Report which genes show highest variability
# TODO: Describe impact on clustering (stronger/weaker separation)
# TODO: Recommend which gene set to use for downstream analyses
# TODO: DECISION: Choose clustering result for Investigations 3-7

# ============================================================================
# INVESTIGATION 3: Differential Expression Analysis
# RQ 2.3: Which genes are differentially expressed between clusters?
# ============================================================================

## GOAL: Identify marker genes that distinguish patient clusters

## Step 3.1: Prepare data for DE analysis
# TODO: Use original raw counts (not normalized/transformed)
# TODO: Add cluster assignments to sample metadata
# TODO: Verify cluster labels match sample order

## Step 3.2: Set up DESeq2 for multi-group comparison
# TODO: Create DESeq2 object with cluster as design variable
# TODO: Run DESeq2 normalization and dispersion estimation
# TODO: Fit negative binomial model

## Step 3.3: Pairwise DE comparisons
# TODO: Extract results for all pairwise cluster comparisons
#       Example: If 3 clusters, test: 1vs2, 1vs3, 2vs3
# TODO: For each comparison:
#       - Extract results table
#       - Apply significance thresholds (padj < 0.05, |log2FC| > 1)
#       - Count number of DE genes
#       - Separate upregulated vs downregulated

## Step 3.4: Identify cluster-specific markers
# TODO: Find genes uniquely upregulated in each cluster
# TODO: Create Venn diagram of DE genes across comparisons
# TODO: List top 10-20 marker genes per cluster (by log2FC or padj)

## Step 3.5: Visualizations
# TODO: Volcano plots for each pairwise comparison
# TODO: MA plots to check for systematic bias
# TODO: Heatmap of top DE genes across all samples
# TODO: Boxplots for selected marker genes

## Step 3.6: Functional annotation of DE genes
# TODO: For each cluster's markers, note gene functions
# TODO: Are markers enriched for specific biological processes?
# TODO: Do markers make biological sense for phenotype differences?

## CONCLUSION FOR RQ 2.3:
# TODO: Report total number of DE genes between clusters
# TODO: Highlight strongest marker genes for each cluster
# TODO: Describe biological themes (immune, metabolic, proliferation, etc.)
# TODO: Save DE results tables for pathway analysis

# ============================================================================
# INVESTIGATION 4: Pathway Enrichment Analysis
# RQ 2.4: Which biological pathways are enriched in DE genes?
# ============================================================================

## GOAL: Identify functional pathways that differentiate clusters

## Step 4.1: Define gene sets for enrichment
# TODO: Filter DE genes by p-value threshold (use average p-value as cutoff)
# TODO: For each cluster comparison, create list of significant genes
# TODO: Consider separate analyses for up- vs down-regulated genes

## Step 4.2: Gene ID conversion
# TODO: Convert gene symbols to Entrez IDs (required for clusterProfiler)
# TODO: Handle genes that fail to convert
# TODO: Document conversion success rate

## Step 4.3: GO enrichment analysis
# TODO: Run enrichGO for Biological Process (BP)
# TODO: Run enrichGO for Molecular Function (MF)
# TODO: Run enrichGO for Cellular Component (CC)
# TODO: Set significance threshold (padj < 0.05)
# TODO: Specify background gene set (all expressed genes)

## Step 4.4: KEGG pathway enrichment
# TODO: Run enrichKEGG analysis
# TODO: Set organism code (e.g., "hsa" for human)
# TODO: Apply multiple testing correction

## Step 4.5: Alternative pathway databases (optional)
# TODO: Consider Reactome, MSigDB, WikiPathways
# TODO: Disease-specific databases if relevant

## Step 4.6: Visualizations
# TODO: Dotplot of top enriched pathways (by p-value and gene ratio)
# TODO: Barplot of enrichment scores
# TODO: Network plot showing pathway relationships
# TODO: Enrichment map connecting related pathways

## Step 4.7: Cluster-specific pathway profiles
# TODO: Compare enriched pathways across all clusters
# TODO: Which pathways are unique to each cluster?
# TODO: Which pathways are shared?
# TODO: Create summary table of key pathways per cluster

## Step 4.8: Biological interpretation
# TODO: Do pathways align with known disease subtypes?
# TODO: Are there actionable therapeutic targets?
# TODO: Do pathways explain clinical differences?

## CONCLUSION FOR RQ 2.4:
# TODO: List top 5-10 pathways for each cluster
# TODO: Describe biological themes (e.g., immune activation, cell cycle)
# TODO: Highlight novel or unexpected pathway enrichments
# TODO: Relate pathway findings back to DE genes from Investigation 3

# ============================================================================
# INVESTIGATION 5: Clinical Outcome Analysis
# RQ 2.5: Do expression-based clusters differ in patient outcomes?
# ============================================================================

## GOAL: Determine if molecular clusters predict clinical outcomes

## Step 5.1: Prepare survival data
# TODO: Extract survival time and event status from clinical data
# TODO: Verify data format (time = numeric, status = 0/1 or 1/2)
# TODO: Handle missing or censored data appropriately
# TODO: Add cluster assignments to survival data

## Step 5.2: Descriptive statistics
# TODO: Calculate median survival time per cluster
# TODO: Count number of events (deaths/relapses) per cluster
# TODO: Tabulate follow-up time distribution

## Step 5.3: Kaplan-Meier survival analysis
# TODO: Fit survival curves for each cluster
# TODO: Plot Kaplan-Meier curves with confidence intervals
# TODO: Add risk table showing n at risk over time
# TODO: Customize plot aesthetics (colors, labels)

## Step 5.4: Statistical testing
# TODO: Perform log-rank test across all clusters
# TODO: Report chi-square statistic and p-value
# TODO: If >2 clusters, do pairwise log-rank tests with correction
# TODO: Interpret significance of survival differences

## Step 5.5: Cox proportional hazards model
# TODO: Fit Cox model with cluster as predictor
# TODO: Calculate hazard ratios (HR) for each cluster
# TODO: Test proportional hazards assumption
# TODO: Report HRs with 95% confidence intervals

## Step 5.6: Multivariable survival analysis
# TODO: Add clinical covariates (age, stage, sex) to Cox model
# TODO: Determine if clusters remain prognostic after adjustment
# TODO: Check for confounding or effect modification
# TODO: Report adjusted HRs

## Step 5.7: Survival prediction performance
# TODO: Calculate concordance index (C-index) for cluster-based model
# TODO: Compare to clinical-only model
# TODO: Assess added prognostic value of molecular clusters

## CONCLUSION FOR RQ 2.5:
# TODO: Report whether clusters have significantly different outcomes
# TODO: Identify high-risk vs low-risk clusters
# TODO: Quantify magnitude of difference (median survival, HR)
# TODO: State whether molecular clusters add prognostic value beyond clinical factors

# ============================================================================
# INVESTIGATION 6: Variability by Clinical Factors
# RQ 2.6: Which genes exhibit the greatest variability in expression by age?
# ============================================================================

# Step 1: Calculate variance for each gene
```{r}
gene_vars <- apply(vst_counts, 1, var)

cat("Total number of genes:", length(gene_vars), "\n")
cat("Variance range:", range(gene_vars), "\n\n")
```

# Step 2: Examine variance distribution
# To understand what a reasonable cutoff is
```{r}
summary(gene_vars)

# Genes with variance > 0.5
sum(gene_vars > 0.5)
# Genes with variance > 0.3
sum(gene_vars > 0.3)
```

# Reduce computational burden while retaining biologically relevant genes
# Select top 10,000 genes by variance across all samples
### Computationally feasible, tests enough genes to capture age-related variability (5000 was deemed too restrictive), removes very low-variance genes (likely noise)
# Step 3: Select top 10000 most variable genes
```{r}
top_genes_10k <- names(sort(gene_vars, decreasing = TRUE))[1:10000]

# Create subset matrices for downstream analysis
expr_vst_top10k <- vst_counts[top_genes_10k, ]
expr_z_top10k <- z_vst[top_genes_10k, ]

cat("Filtered VST matrix dimensions:", dim(expr_vst_top10k), "\n")
cat("Filtered Z-scored VST matrix dimensions:", dim(expr_z_top10k), "\n\n")
```
# Step 4: Matching expression data with age data
```{r}
# Extract age data from clinical information
age_data <- data_clinical_patient[, c("PATIENT_ID", "AGE")]
age_data <- age_data[!is.na(age_data$AGE), ]

cat("Total patients with age data:", nrow(age_data), "\n")
cat("Age range:", range(age_data$AGE), "\n")
cat("Age distribution:\n")
print(summary(age_data$AGE))

# Create age groups for visualization and categorical analysis
age_data$age_group <- cut(age_data$AGE, 
                          breaks = c(0, 50, 60, 70, 100),
                          labels = c("0-49", "50-59", "60-69", "70+"),
                          include.lowest = TRUE)

cat("\nAge group distribution:\n")
print(table(age_data$age_group))

# Match samples between expression and clinical data
common_patients <- intersect(colnames(expr_vst_top10k), age_data$PATIENT_ID)
cat("\nPatients in both datasets:", length(common_patients), "\n")

# Filter and align both datasets
expr_matched <- expr_vst_top10k[, common_patients]
age_matched <- age_data[age_data$PATIENT_ID %in% common_patients, ]
age_matched <- age_matched[match(colnames(expr_matched), age_matched$PATIENT_ID), ]

# Verify alignment
stopifnot(all(colnames(expr_matched) == age_matched$PATIENT_ID))
cat("Data alignment verified!\n\n")
```

#Restart
# STEP 1: Merge Cluster Assignments with Age Data
```{r}
# Extract age data from clinical information
age_data <- data_clinical_patient[, c("PATIENT_ID", "AGE")]
age_data <- age_data[!is.na(age_data$AGE), ]

# Merge with cluster assignments
age_cluster_data <- merge(cluster_df, age_data, by = "PATIENT_ID")

cat("Total patients with both cluster and age data:", nrow(age_cluster_data), "\n")
cat("Age range:", range(age_cluster_data$AGE), "\n\n")

# Add age groups
age_cluster_data$age_group <- cut(age_cluster_data$AGE, 
                                   breaks = c(0, 40, 60, 80, 100),
                                   labels = c("Young", "Middle", "Senior", "Elderly"),
                                   include.lowest = TRUE)

# Summary statistics by cluster
cat("=== Age Distribution by Cluster ===\n")
age_summary <- aggregate(AGE ~ Cluster_Label, data = age_cluster_data, 
                         FUN = function(x) c(Mean = mean(x), 
                                             SD = sd(x), 
                                             Median = median(x),
                                             Min = min(x),
                                             Max = max(x)))
print(age_summary)
cat("\n")

```




## GOAL: Characterize clinical profiles of molecular clusters

## Step 6.1: Prepare clinical data
# TODO: Merge cluster assignments with clinical data
# TODO: Identify all available clinical variables
# TODO: Classify variables as continuous vs categorical
# TODO: Handle missing data (document and decide on exclusion/imputation)

## Step 6.2: Continuous variables analysis
# TODO: For each continuous variable (age, BMI, lab values):
#       - Test normality within each cluster (Shapiro-Wilk)
#       - Choose appropriate test: ANOVA (normal) or Kruskal-Wallis (non-normal)
#       - Calculate test statistic and p-value
#       - Perform post-hoc pairwise tests if significant
# TODO: Create summary table with mean/median per cluster

## Step 6.3: Visualize continuous variables
# TODO: Boxplots for each variable by cluster
# TODO: Violin plots showing distributions
# TODO: Add statistical annotations (p-values)

## Step 6.4: Categorical variables analysis
# TODO: For each categorical variable (sex, stage, race, etc.):
#       - Create contingency table (cluster x category)
#       - Perform chi-square or Fisher's exact test
#       - Calculate Cramér's V for effect size
#       - Report observed vs expected frequencies
# TODO: Create summary table with proportions per cluster

## Step 6.5: Visualize categorical variables
# TODO: Stacked or grouped bar plots showing proportions
# TODO: Mosaic plots for complex cross-tabulations
# TODO: Highlight significant associations

## Step 6.6: Disease stage/grade analysis
# TODO: Test if clusters associate with disease severity
# TODO: Are certain clusters enriched for advanced stage?
# TODO: Calculate odds ratios for stage by cluster

## Step 6.7: Multiple testing correction
# TODO: Adjust p-values for multiple comparisons (Bonferroni or FDR)
# TODO: Report both raw and adjusted p-values
# TODO: Interpret significance after correction

## Step 6.8: Multivariate analysis
# TODO: Use multinomial logistic regression (cluster as outcome)
# TODO: Include multiple clinical predictors simultaneously
# TODO: Identify independent clinical predictors of cluster membership

## Step 6.9: Clinical cluster profiling
# TODO: Create comprehensive profile for each cluster
# TODO: Example: "Cluster 1: younger, more female, early stage"
# TODO: Identify clinically distinct subtypes

## CONCLUSION FOR RQ 2.6:
# TODO: Summarize which clinical variables differ significantly
# TODO: Describe clinical profile of each cluster
# TODO: Assess whether clusters represent clinically meaningful subtypes
# TODO: Discuss implications for patient stratification

# ============================================================================
# INVESTIGATION 7: Mutation Enrichment Analysis
# RQ 2.7: Are specific mutations enriched in particular clusters?
# ============================================================================

## GOAL: Link genetic alterations to expression-based subtypes

## Step 7.1: Prepare mutation data
# TODO: Ensure mutation data matches sample IDs in expression data
# TODO: Verify mutation format (binary, count, or VAF)
# TODO: Document mutation prevalence (% samples affected per mutation)
# TODO: Merge cluster assignments with mutation data

## Step 7.2: Individual mutation testing
# TODO: For each mutation:
#       - Create 2x2 or 2xK contingency table (mutation x cluster)
#       - Perform Fisher's exact test (if small counts) or chi-square
#       - Calculate odds ratios for mutation in each cluster
#       - Record p-value and effect size
# TODO: Create results table for all mutations tested

## Step 7.3: Multiple testing correction
# TODO: Adjust p-values across all mutation tests (FDR/Bonferroni)
# TODO: Identify mutations with significant enrichment after correction
# TODO: Rank mutations by significance

## Step 7.4: Visualize mutation enrichment
# TODO: Heatmap showing mutation frequency per cluster
# TODO: Bar plots for significantly enriched mutations
# TODO: Stacked bar plots showing proportion mutated per cluster
# TODO: Consider oncoplot-style visualization

## Step 7.5: Cluster-specific mutation profiles
# TODO: For each cluster, list enriched mutations
# TODO: Calculate enrichment fold-change vs other clusters
# TODO: Identify mutually exclusive or co-occurring mutations

## Step 7.6: Mutation burden analysis
# TODO: Calculate total mutation count per sample
# TODO: Test if clusters differ in overall mutation burden
# TODO: Use ANOVA or Kruskal-Wallis test
# TODO: Visualize with boxplots

## Step 7.7: Pathway-level mutation analysis
# TODO: Group mutations by affected pathway (e.g., TP53, RAS, PI3K)
# TODO: Test pathway-level enrichment in clusters
# TODO: Does cluster with pathway X mutations have pathway X expression changes?

## Step 7.8: Mutation-expression correlation
# TODO: For enriched mutations, examine expression of mutated gene
# TODO: Do mutations correlate with gene expression changes?
# TODO: Are there compensatory expression changes?

## Step 7.9: Integration with DE genes
# TODO: Cross-reference with Investigation 3 results
# TODO: Do clusters with specific mutations show corresponding expression signatures?
# TODO: Example: Are TP53-mutated samples in a specific cluster with p53 pathway dysregulation?

## Step 7.10: Biological interpretation
# TODO: Do mutation patterns explain molecular subtypes?
# TODO: Are there known oncogenic driver mutations enriched in clusters?
# TODO: Do findings suggest distinct disease etiologies?

## CONCLUSION FOR RQ 2.7:
# TODO: List mutations significantly enriched in each cluster
# TODO: Report magnitude of enrichment (OR, fold-change)
# TODO: Describe mutation-based characterization of each cluster
# TODO: Discuss whether mutations drive observed expression differences
# TODO: Identify potential therapeutic vulnerabilities based on mutations

# ============================================================================
# STEP 3: INTEGRATED SYNTHESIS AND FINAL CONCLUSIONS
# ============================================================================

## Step 3.1: Cross-investigation integration
# TODO: Create comprehensive table summarizing all clusters:
#       - Size, marker genes, pathways, outcome, clinical features, mutations
# TODO: Develop unified narrative for each cluster
# TODO: Name clusters based on characteristics (e.g., "Immune-hot", "Proliferative")

## Step 3.2: Validate findings
# TODO: Check consistency across investigations
# TODO: Do DE genes align with enriched pathways?
# TODO: Do mutations explain expression patterns?
# TODO: Are clinical features consistent with molecular profiles?

## Step 3.3: Biological coherence
# TODO: Assess whether clusters represent biologically distinct subtypes
# TODO: Compare to known disease classifications or published subtypes
# TODO: Discuss novelty or confirmation of findings

## Step 3.4: Clinical relevance
# TODO: Identify actionable clusters (targetable pathways/mutations)
# TODO: Recommend cluster-specific treatment strategies
# TODO: Suggest prognostic biomarkers based on cluster membership

## Step 3.5: Limitations and caveats
# TODO: Document sample size limitations
# TODO: Note any batch effects or technical confounders
# TODO: Acknowledge multiple testing burden
# TODO: Discuss generalizability

## Step 3.6: Future directions
# TODO: Suggest validation in independent cohort
# TODO: Propose functional experiments to test hypotheses
# TODO: Recommend additional molecular data types (methylation, proteomics)

## FINAL DELIVERABLES:
# TODO: Summary figure showing cluster characteristics
# TODO: Supplementary tables with all statistical results
# TODO: Write methods section documenting all analyses
# TODO: Prepare results section with key findings per RQ

# ============================================================================
# END OF TEMPLATE
# ============================================================================

```{r}

# Investigation 8: Top 500 Variable Genes by Tumor Stage

# RQ 2.8: Which genes exhibit the greatest variability in expression by tumor stage?
# H8: Higher tumor stage correlates with oncogene expression

library(ggplot2)
library(pheatmap)
library(biomaRt)   
library(dplyr)    

cat("Investigation 8: Variable Genes by Stage\n")

#Fix gene data ID's to correct format

# Problem: Ensembl IDs have version numbers (e.g., ENSG00000000003.15)
# Solution: Remove version numbers and map to readable gene symbols (HGNC)

cat("Fixing Ensembl gene IDs and mapping to gene symbols...\n")

# Use log_norm_counts from the preprocessing script
# This is log2(normalized_counts + 1)
log2_counts <- log_norm_counts

# Also prepare z-scores for visualization later
z_scores <- z_log

# Remove version numbers from Ensembl IDs (everything after the dot)
clean_ids <- sub("\\..*", "", rownames(log2_counts))

# Update rownames with clean IDs
rownames(log2_counts) <- clean_ids
rownames(z_scores) <- clean_ids

# Connect to Ensembl BioMart to get gene symbol mappings
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query BioMart: get gene symbols for our Ensembl IDs
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = clean_ids,
  mart = mart
)

# Convert matrix to dataframe for joining
expr_df <- as.data.frame(log2_counts)
expr_df$ensembl_gene_id <- rownames(expr_df)

# Join expression data with gene symbol mapping
expr_merged <- expr_df %>%
  left_join(mapping, by = "ensembl_gene_id")

# Drop genes without symbols (unannotated genes)
expr_merged <- expr_merged %>% filter(hgnc_symbol != "")

# Remove duplicates (some Ensembl IDs map to same symbol)
expr_merged <- expr_merged %>% distinct(hgnc_symbol, .keep_all = TRUE)

# Set gene symbols as rownames for easy access
rownames(expr_merged) <- expr_merged$hgnc_symbol

# Remove helper columns
expr_merged$ensembl_gene_id <- NULL
expr_merged$hgnc_symbol <- NULL

# Convert back to matrix
expr_symbol <- as.matrix(expr_merged)

# Do the same for z-scores
z_df <- as.data.frame(z_scores)
z_df$ensembl_gene_id <- rownames(z_df)

z_merged <- z_df %>%
  left_join(mapping, by = "ensembl_gene_id") %>%
  filter(hgnc_symbol != "") %>%
  distinct(hgnc_symbol, .keep_all = TRUE)

rownames(z_merged) <- z_merged$hgnc_symbol
z_merged$ensembl_gene_id <- NULL
z_merged$hgnc_symbol <- NULL

z_scores <- as.matrix(z_merged)

cat("Gene ID conversion complete.\n")
cat("Number of genes after symbol mapping:", nrow(expr_symbol), "\n")


# Step 1: Match RNA Seq data to clinical stage data

# Problem: RNA-seq sample IDs don't exactly match clinical patient IDs
# Solution: Extract patient ID (first 12 characters) and join with clinical data

cat("Matching samples to clinical stage\n")

# Extract patient ID from RNA-seq sample names
# Example: TCGA.AB.2842.03A.01R → TCGA-AB-2842
rnaseq_patient_ids <- substr(gsub("\\.", "-", colnames(expr_symbol)), 1, 12)

# Create lookup table
stage_info <- data.frame(
  sample_id = colnames(expr_symbol),
  patient_id = rnaseq_patient_ids,
  stringsAsFactors = FALSE
)

# Join with clinical data to get stage information
stage_info <- stage_info %>%
  left_join(
    data_clinical_patient %>% 
      dplyr::select(PATIENT_ID, AJCC_PATHOLOGIC_TUMOR_STAGE) %>%
      rename(patient_id = PATIENT_ID, stage = AJCC_PATHOLOGIC_TUMOR_STAGE),
    by = "patient_id"
  ) %>%
  filter(!is.na(stage) & stage != "")  # Keep only samples with stage data

cat("Samples with stage info:", nrow(stage_info), "\n")
print(table(stage_info$stage))

# Subset expression matrix to only samples with stage data
expr_staged <- expr_symbol[, stage_info$sample_id]


# Step 2: Variance and top 500 genes

# Goal: Find genes with highest variability across samples
# Why: Variable genes are more likely to be biologically meaningful

cat("\nSelecting top 500 most variable genes\n")

# Calculate variance for each gene across all samples
gene_variance <- apply(expr_staged, 1, var)

# Select top 500 genes with highest variance
top500_genes <- names(sort(gene_variance, decreasing = TRUE)[1:500])

cat("Top 500 genes selected\n")
cat("Variance range:", range(gene_variance[top500_genes]), "\n\n")


# Step 3: Anova test

# Question: Do any of these 500 genes differ significantly by stage?
# Method: One-way ANOVA (tests if means differ across stage groups)

cat("Testing gene expression vs stage (ANOVA)\n")

anova_results <- data.frame(
  gene = top500_genes,
  p_value = sapply(top500_genes, function(g) {
    # ANOVA: does expression of gene g differ by stage?
    fit <- aov(expr_staged[g, ] ~ factor(stage_info$stage))
    summary(fit)[[1]]["Pr(>F)"][1, 1]  # Extract p-value
  }),
  stringsAsFactors = FALSE
)

# Adjust p-values for multiple testing (Benjamini-Hochberg FDR)
anova_results$p_adj <- p.adjust(anova_results$p_value, method = "BH")
anova_results$significant <- anova_results$p_adj < 0.05

cat("Significant genes (FDR < 0.05):", sum(anova_results$significant), "\n\n")

cat("Top 10 genes:\n")
print(anova_results %>% arrange(p_adj) %>% head(10))


# Step 4: Visualizations
# Create heatmap and boxplots to visualize patterns

# Get z-scored expression for top 500 genes
# Using z_scores here for visualization (standardized scale)
top500_matrix <- z_scores[top500_genes, stage_info$sample_id]

# Annotation for heatmap columns
annotation <- data.frame(
  Stage = factor(stage_info$stage),
  row.names = stage_info$sample_id
)

# Heatmap: shows all 500 genes clustered by expression pattern
pheatmap(
  top500_matrix,
  annotation_col = annotation,
  show_rownames = FALSE,
  show_colnames = FALSE,
  main = "Top 500 Variable Genes by Stage"
)

# Boxplots: show top 3 most significant genes in detail
top3_genes <- head(anova_results %>% arrange(p_adj), 3)$gene

for (gene in top3_genes) {
  plot_data <- data.frame(
    expression = expr_staged[gene, ],  # Using log2_counts here for actual values
    stage = factor(stage_info$stage)
  )
  
  print(
    ggplot(plot_data, aes(stage, expression, fill = stage)) +
      geom_boxplot() +
      labs(title = paste("Gene:", gene), x = "Stage", y = "Log2 Expression") +
      theme_bw()
  )
}


# Step 5: Test oncogene hypothesis (H8)
# H8: Higher tumor stage correlates with oncogene expression
# Method: Check if known oncogenes are variable and correlate with stage

cat("\nTesting oncogene hypothesis\n")

# List of known oncogenes
oncogenes <- c("MYC","KRAS","NRAS","HRAS","EGFR","ERBB2","PIK3CA",
               "BRAF","AKT1","AKT2","MDM2","CCND1","CDK4","CDK6",
               "MET","RET","ALK","ROS1","FGFR1","FGFR2")

# Check which oncogenes are present in our dataset
all_genes <- rownames(expr_staged)
oncogenes_in_data <- intersect(all_genes, oncogenes)

cat("\nOncogenes present in dataset:", length(oncogenes_in_data), "\n")
print(oncogenes_in_data)

# Check which oncogenes are in the top 500 most variable genes
oncogenes_in_top500 <- intersect(top500_genes, oncogenes)
cat("\nOncogenes in top 500 variable genes:", length(oncogenes_in_top500), "\n")
print(oncogenes_in_top500)


# Test all oncogenes present in data (not just top 500) 
# This could be more exciting and give us different values
if (length(oncogenes_in_data) > 0) {
  cat("\nTesting ALL oncogenes for stage correlation\n")
  
  oncogene_results_all <- data.frame(
    gene = oncogenes_in_data,
    correlation = NA,
    p_value = NA,
    direction = NA,
    in_top500 = oncogenes_in_data %in% top500_genes
  )
  
  for (i in seq_along(oncogenes_in_data)) {
    gene <- oncogenes_in_data[i]
    
    # Convert stage to numeric for correlation
    # Stage I=1, Stage II=2, Stage III=3, Stage IV=4
    stage_numeric <- as.numeric(factor(stage_info$stage, 
                                       levels = c("STAGE I", "STAGE II", 
                                                  "STAGE III", "STAGE IV")))
    
    # Spearman correlation: does expression correlate with stage number?
    cor_test <- cor.test(stage_numeric, 
                         expr_staged[gene, ],
                         method = "spearman")
    
    oncogene_results_all$correlation[i] <- cor_test$estimate
    oncogene_results_all$p_value[i] <- cor_test$p.value
    oncogene_results_all$direction[i] <- ifelse(cor_test$estimate > 0, "UP", "DOWN")
  }
  
  oncogene_results_all$p_adj <- p.adjust(oncogene_results_all$p_value, method = "BH")
  oncogene_results_all$significant <- oncogene_results_all$p_adj < 0.05
  
  cat("\nOncogene correlation results:\n")
  print(oncogene_results_all %>% arrange(p_adj))
  
  # Create boxplots for significant oncogenes
  sig_oncogenes <- oncogene_results_all %>% 
    filter(significant) %>% 
    pull(gene)
  
  if (length(sig_oncogenes) > 0) {
    cat("\nCreating boxplots for significant oncogenes...\n")
    
    for (gene in sig_oncogenes) {
      plot_data <- data.frame(
        expression = expr_staged[gene, ],
        stage = factor(stage_info$stage)
      )
      
      print(
        ggplot(plot_data, aes(stage, expression, fill = stage)) +
          geom_boxplot() +
          labs(title = paste("Oncogene:", gene), 
               x = "Stage", 
               y = "Log2 Expression") +
          theme_bw()
      )
    }
  }
  
} else {
  cat("\nNo oncogenes found in dataset.\n")
}

# Original test (only for oncogenes in top 500)
if (length(oncogenes_in_top500) > 0) {
  cat("\nOncogenes in top 500 variable genes\n")
  
  oncogene_results <- data.frame(
    gene = oncogenes_in_top500,
    correlation = NA,
    p_value = NA,
    direction = NA
  )
  
  for (i in seq_along(oncogenes_in_top500)) {
    gene <- oncogenes_in_top500[i]
    
    stage_numeric <- as.numeric(factor(stage_info$stage, 
                                       levels = c("STAGE I", "STAGE II", 
                                                  "STAGE III", "STAGE IV")))
    
    cor_test <- cor.test(stage_numeric, 
                         expr_staged[gene, ],
                         method = "spearman")
    
    oncogene_results$correlation[i] <- cor_test$estimate
    oncogene_results$p_value[i] <- cor_test$p.value
    oncogene_results$direction[i] <- ifelse(cor_test$estimate > 0, "UP", "DOWN")
  }
  
  oncogene_results$p_adj <- p.adjust(oncogene_results$p_value, method = "BH")
  oncogene_results$significant <- oncogene_results$p_adj < 0.05
  
  print(oncogene_results)
  
} else {
  cat("\nNo oncogenes found among top 500 variable genes.\n")
  cat("This is not necessarily wrong - see analysis of ALL oncogenes above.\n")
}


# Conclusion
cat("\nConclusion for RQ 2.8 & H8\n")

cat("1. Top 500 most variable genes identified.\n")
cat("2. ", sum(anova_results$significant), "genes significantly associated with stage.\n")
cat("3. Oncogenes in dataset:", length(oncogenes_in_data), "\n")
cat("4. Oncogenes in top 500 variable:", length(oncogenes_in_top500), "\n")

# Modified conclusion based on all oncogenes, not just top 500
if (
  length(oncogenes_in_data) > 0 &&
  any(oncogene_results_all$significant & oncogene_results_all$direction == "UP")
) {
  cat("\nH8 SUPPORTED: Some oncogenes increase with tumor stage.\n")
  sig_onco <- oncogene_results_all %>% 
    filter(significant, direction == "UP") %>%
    pull(gene)
  cat("Significant oncogenes with UP regulation:", paste(sig_onco, collapse = ", "), "\n")
} else {
  cat("\n H8 NOT SUPPORTED: No oncogenes show significant stage-dependent increases.\n")
}
```


